% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bootstrapping.R
\name{bootstrap_trendfilter}
\alias{bootstrap_trendfilter}
\title{Construct pointwise variability bands via a tailored bootstrap algorithm}
\usage{
bootstrap_trendfilter(
  obj,
  algorithm = c("nonparametric", "parametric", "wild"),
  B = 100L,
  x_eval = NULL,
  edf = NULL,
  mc_cores = parallel::detectCores() - 4,
  ...
)
}
\arguments{
\item{obj}{An object of class '\code{\link[=cv_trendfilter]{cv_trendfilter}}' or
'\code{\link[=sure_trendfilter]{sure_trendfilter}}'.}

\item{algorithm}{A string specifying which variation of the bootstrap to use. One of
\code{c("nonparametric", "parametric", "wild")}. See \emph{Details} section below for
guidelines on when each choice should be used.}

\item{B}{The number of bootstrap samples used to estimate the pointwise variability
bands. Defaults to \code{B = 100L}.}

\item{edf}{The desired number of effective degrees of freedom in each bootstrap
estimate. When \code{obj} is of class
'\code{\link[=sure_trendfilter]{sure_trendfilter}}', \code{edf = obj$edf_min} and
\code{edf = obj$edf_1se} are advisible options. When \code{obj} is of class
'\code{\link[=cv_trendfilter]{cv_trendfilter}}', any element of the (now vectors)
\code{obj$edf_min} and \code{obj$edf_1se} may be a reasonable choice. Defaults to
\code{edf = obj$edf_min["MAE"]}.}

\item{mc_cores}{Number of cores to utilize for parallel computing. Defaults to the number
of cores detected, minus 4.}

\item{...}{Additional named arguments. Currently only a few experimental arguments
may be passed by experts.}
}
\value{
An object of class '\code{bootstrap_trendfilter}' and subclass
'\code{\link[=trendfilter]{trendfilter}}'. This is a list with the elements below,
as well as all elements from \code{obj}.
\describe{
\item{\code{x_eval}}{Input grid that each bootstrap trend filtering estimate was
evaluated on.}
\item{\code{ensemble}}{The full trend filtering bootstrap ensemble as a matrix
with \code{length(x_eval)} rows and \code{B} columns.}
\item{\code{algorithm}}{String specifying which variation of the bootstrap was
used to generate the ensemble.}
\item{\code{edf_opt}}{Number of effective degrees of freedom that each bootstrap
trend filtering fit should approximately possess in our fixed-edf bootstrap
procedure. Determined by the \code{edf} input argument of
\code{bootstrap_trendfilter()}.}
\item{\code{i_opt}}{Index of \code{obj$edf} that gives \code{edf_opt}.}
\item{\code{edf_boots}}{Vector of the estimated number of effective degrees of
freedom of each trend filtering bootstrap estimate.}
\item{\code{n_iter_boots}}{Vector of the number of iterations taken by the ADMM
algorithm before reaching a stopping criterion, for each bootstrap estimate.}
\item{\code{lambda_boots}}{Vector of the hyperparameter values used for each
bootstrap fit. In general, these are not all equal because our bootstrap
implementation instead seeks to hold the number of effective degrees of
freedom constant across all bootstrap estimates.}
\item{\code{lambda}}{Vector of the original grid of candidate hyperparameter
values, inherited from \code{obj}.}
\item{\code{edf}}{Number of effective degrees of freedom in the trend filtering
estimator, for every hyperparameter value in \code{lambda}.}
\item{\code{fitted_values}}{Fitted values of all trend filtering point
estimates with hyperparameter values in \code{lambda}, inherited from \code{obj}.}
\item{\code{x}}{Vector of observed values for the input variable, inherited from
\code{obj}.}
\item{\code{y}}{Vector of observed values for the output variable, inherited from
\code{obj}.}
\item{\code{weights}}{Vector of weights for the observed outputs, inherited from
\code{obj}.}
\item{\code{k}}{Degree of the trend filtering point estimate (and bootstrap
estimates), inherited from \code{obj}.}
\item{\code{call}}{The function call.}
\item{\code{scale}}{For internal use.}
}
}
\description{
Generate a bootstrap ensemble of trend filtering estimates in order to
quantify the uncertainty in the optimized estimate. One of three possible
bootstrap algorithms should be chosen according to the criteria in the
\emph{Details} section below. Pointwise variability bands are then obtained by
passing the '\code{bootstrap_trendfilter}' object to \code{\link[=vbands]{vbands()}}, along with the
desired level (e.g. \code{level = 0.95}) .
}
\details{
Our recommendations for when to use each of the possible settings
for the \code{algorithm} argument are shown in the table below. See
\href{https://academic.oup.com/mnras/article/492/3/4005/5704413}{Politsch et al. (2020a)} for more details.\tabular{ll}{
   Scenario \tab Uncertainty quantification \cr
   \code{x} is unevenly sampled \tab \code{algorithm = "nonparametric"} \cr
   \code{x} is evenly sampled and measurement variances for \code{y} are available \tab \code{algorithm = "parametric"} \cr
   \code{x} is evenly sampled and measurement variances for \code{y} are not available \tab \code{algorithm = "wild"} \cr
}


For our purposes, an evenly sampled data set with some discarded pixels
(either sporadically or in large consecutive chunks) is still considered to
be evenly sampled. When the inputs are evenly sampled on a transformed scale,
we recommend transforming to that scale and carrying out the full trend
filtering analysis on that scale. See Example 2 below for a case when the
inputs are evenly sampled on the \code{log10(x)} scale.
}
\examples{
# Example 1: Phase-folded light curve of an eclipsing binary star system
#
# The apparent brightness over time of a star system that has two suns
# that regularly eclipse one another from our vantage point on Earth. Here,
# the time series is stacked according to the orbital period of the binary
# system, with the primary eclipse occuring at `phase = 0` and the input
# domain ranging from -0.5 to 0.5.

data("eclipsing_binary")
head(eclipsing_binary)

x <- eclipsing_binary$phase
y <- eclipsing_binary$flux
weights <- 1 / eclipsing_binary$std_err^2

cv_tf <- cv_trendfilter(x, y, weights, max_iter = 1e4, obj_tol = 1e-6)

\dontrun{
boot_tf <- bootstrap_trendfilter(
  obj = cv_tf,
  algorithm = "nonparametric",
  edf = cv_tf$edf_min["MAE"]
)
}

# Example 2: The "Lyman-alpha forest" in the spectrum of a distant quasar

data("quasar_spectrum")
head(quasar_spectrum)

x <- quasar_spectrum$log10_wavelength
y <- quasar_spectrum$flux
weights <- quasar_spectrum$weights

sure_tf <- sure_trendfilter(x, y, weights)
boot_tf <- bootstrap_trendfilter(
  obj = sure_tf,
  algorithm = "parametric",
  edf = sure_tf$edf_min
)
}
\references{
\enumerate{
\item Politsch et al. (2020a). Trend filtering – I. A modern statistical tool
for time-domain astronomy and astronomical spectroscopy. \emph{MNRAS}, 492(3),
p. 4005-4018.
[\href{https://academic.oup.com/mnras/article/492/3/4005/5704413}{Publisher}]
[\href{https://arxiv.org/abs/1908.07151}{arXiv}].
\item Politsch et al. (2020b). Trend Filtering – II. Denoising astronomical
signals with varying degrees of smoothness. \emph{MNRAS}, 492(3), p. 4019-4032.
[\href{https://academic.oup.com/mnras/article/492/3/4019/5704414}{Publisher}]
[\href{https://arxiv.org/abs/2001.03552}{arXiv}].
}
}
\seealso{
\code{\link[=cv_trendfilter]{cv_trendfilter()}}, \code{\link[=sure_trendfilter]{sure_trendfilter()}}
}
