% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/trendfilter.R
\name{.trendfilter}
\alias{.trendfilter}
\alias{dot-trendfilter}
\title{Fit a trend filtering model (front-end function focused on ease of use)}
\usage{
.trendfilter(
  x,
  y,
  weights = NULL,
  lambda,
  edf = NULL,
  k = 2L,
  obj_tol = 1e-10,
  max_iter = length(y),
  ...
)
}
\arguments{
\item{x}{Vector of observed values for the input variable.}

\item{y}{Vector of observed values for the output variable.}

\item{weights}{Weights for the output measurements. Output weights are defined as the
inverse variance of the additive noise that contaminates the output signal.
When the noise is expected to have a constant variance \mjseqn{\sigma^2}
over all outputs, a scalar may be passed to \code{weights}, i.e.
\verb{weights = }\mjseqn{1/\sigma^2}. Otherwise, \code{weights} must be a vector
with the same length as \code{x} and \code{y}.}

\item{lambda}{One or more hyperparameter values to fit a trend filtering estimate for.}

\item{edf}{(Not yet available) Alternative hyperparametrization for the trend
filtering model(s). Vector of the desired number of effective degrees of
freedom in each model.}

\item{k}{Degree of the polynomials that make up the piecewise-polynomial trend
filtering estimate. Defaults to \code{k = 2} (i.e. a piecewise quadratic
estimate). Must be one of \verb{k = 0,1,2}. Higher order polynomials are
disallowed since they yield no statistical benefit over \code{k = 2} and their
use can lead to instability in the convex optimization.}

\item{obj_tol}{Stopping criterion for the trend filtering convex optimization. If the
relative change in the trend filtering objective function between two
successive iterations is less than \code{obj_tol}, the algorithm terminates.
Defaults to \code{obj_tol = 1e-10}.}

\item{max_iter}{Maximum number of iterations that we will tolerate for the trend filtering
convex optimization algorithm. Defaults to \code{max_iter = length(y)}.}

\item{...}{Additional named arguments. Currently unused.}
}
\value{
An object of class \code{'trendfilter'}. Generic functions such as
\code{\link[=predict]{predict()}}, \code{\link[=fitted.values]{fitted.values()}}, and \code{\link[=residuals]{residuals()}} may be called on
objects of class \code{'trendfilter'}. A \code{'trendfilter'} object is a list with the
following elements:
\describe{
\item{\code{x}}{Vector of observed values for the input variable.}
\item{\code{y}}{Vector of observed values for the output variable (if originally
present, observations with \code{is.na(y)} or \code{weights == 0} are dropped).}
\item{\code{weights}}{Vector of weights for the observed outputs.}
\item{\code{k}}{Degree of the trend filtering estimate.}
\item{\code{lambda}}{Vector of candidate hyperparameter values (always returned
in descending order).}
\item{\code{edf}}{Number of effective degrees of freedom in the trend filtering
estimator, for every hyperparameter value in \code{lambda}.}
\item{\code{fitted_values}}{The fitted values of the trend filtering estimate(s).
If \code{length(lambda) == 1}, fitted values for the single fit are returned as a
numeric vector. Otherwise, fitted values are returned in a matrix with
\code{length(lambda)} columns, with \code{fitted_values[,i]} corresponding to the trend
filtering estimate with hyperparameter \code{lambda[i]}.}
\item{\code{admm_params}}{A list of the parameter values used by the ADMM
algorithm used to solve the trend filtering convex optimization.}
\item{\code{obj_func}}{The relative change in the objective function over the
ADMM algorithm's final iteration, for every hyperparameter value in
\code{lambda}.}
\item{\code{n_iter}}{Total number of iterations taken by the ADMM algorithm, for
every hyperparameter value in \code{lambda}. If an element of \code{n_iter} is exactly
equal to \code{admm_params$max_iter}, then the ADMM algorithm stopped before
reaching the objective tolerance \code{admm_params$obj_tol}. In these situations,
you may need to increase the maximum number of tolerable iterations in order
to ensure that the ADMM solution has converged to satisfactory precision.
This can be done by passing an extra argument \code{max_iter} to the
\code{.trendfilter} function call and increasing it from its default value
\code{max_iter = length(y)}.}
\item{\code{status}}{For internal use. Output from the C solver.}
\item{\code{call}}{The function call.}
\item{\code{scale}}{For internal use.}
}
}
\description{
Fit a trend filtering model.
}
\examples{
data("eclipsing_binary")
head(eclipsing_binary)

x <- eclipsing_binary$phase
y <- eclipsing_binary$flux
weights <- 1 / eclipsing_binary$std_err^2

fit <- .trendfilter(
  x,
  y,
  weights,
  lambda = exp(10),
  obj_tol = 1e-6,
  max_iter = 1e4
)
}
\references{
\enumerate{
\item Politsch et al. (2020a). Trend filtering – I. A modern statistical tool
for time-domain astronomy and astronomical spectroscopy. \emph{MNRAS}, 492(3),
p. 4005-4018.
[\href{https://academic.oup.com/mnras/article/492/3/4005/5704413}{Publisher}]
[\href{https://arxiv.org/abs/1908.07151}{arXiv}].
\item Politsch et al. (2020b). Trend Filtering – II. Denoising astronomical
signals with varying degrees of smoothness. \emph{MNRAS}, 492(3), p. 4019-4032.
[\href{https://academic.oup.com/mnras/article/492/3/4019/5704414}{Publisher}]
[\href{https://arxiv.org/abs/2001.03552}{arXiv}].
}
}
