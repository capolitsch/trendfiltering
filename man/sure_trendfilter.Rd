% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hyperparameter-tuning.R
\name{sure_trendfilter}
\alias{sure_trendfilter}
\title{Optimize a trend filtering model by minimizing Stein's unbiased risk estimate}
\usage{
sure_trendfilter(x, y, weights, nlambda = 250L, ...)
}
\arguments{
\item{x}{Vector of observed values for the input variable.}

\item{y}{Vector of observed values for the output variable.}

\item{weights}{Weights for the observed outputs, defined as the reciprocal variance of the
additive noise that contaminates the output signal. When the noise is
expected to have an equal variance \mjseqn{\sigma^2} for all observations,
a scalar may be passed to \code{weights}, i.e. \verb{weights = }\mjseqn{1/\sigma^2}.
Otherwise, \code{weights} must be a vector with the same length as \code{x} and \code{y}.}

\item{nlambda}{Number of hyperparameter values to test during cross validation. Defaults
to \code{nlambda = 250}. The hyperparameter grid is internally constructed to
span the full trend filtering model space (which is bookended by a global
polynomial solution and an interpolating solution), with \code{nlambda}
controlling the granularity of the hyperparameter grid.}

\item{...}{Additional named arguments to pass to \code{\link[=.trendfilter]{.trendfilter()}}.}
}
\value{
An object of class '\code{sure_trendfilter}' and subclass
'\code{\link[=trendfilter]{trendfilter}}'. Generic functions such as \code{\link[=predict]{predict()}},
\code{\link[=fitted.values]{fitted.values()}}, and \code{\link[=residuals]{residuals()}} may be called on the
\code{\link[=sure_trendfilter]{sure_trendfilter()}} output. A '\code{sure_trendfilter}' object is a list with
the elements below, as well as all elements from the
'\code{\link[=trendfilter]{trendfilter}}' call.
\describe{
\item{\code{lambda}}{Vector of candidate hyperparameter values (always returned
in descending order).}
\item{\code{edf}}{Number of effective degrees of freedom in the trend filtering
estimator, for every hyperparameter value in \code{lambda}.}
\item{\code{error}}{Vector of mean-squared prediction errors estimated by SURE,
for every hyperparameter value in \code{lambda}.}
\item{\code{se_error}}{Vector of estimated standard errors for the \code{error}.}
\item{\code{training_error}}{The "in-sample" MSE between the observed outputs \code{y}
and the trend filtering estimate, for every hyperparameter value in
\code{lambda}.}
\item{\code{optimism}}{SURE-estimated optimisms, i.e.
\code{optimism = error - training_error}.}
\item{\code{lambda_min}}{Hyperparameter value in \code{lambda} that minimizes the SURE
validation error curve.}
\item{\code{lambda_1se}}{The largest hyperparameter value in \code{lambda} that has a
SURE error within one standard error of \code{min(error)}. We call this the
"1-standard-error rule" hyperparameter, and it serves as an Occam's
razor-esque heuristic. More precisely, given two models with approximately
equal performance (here, in terms of predictive MSE), it may be wise to opt
for the simpler model, i.e. the model with the larger hyperparameter value /
fewer effective degrees of freedom.}
\item{\code{edf_min}}{Number of effective degrees of freedom in the trend
filtering estimator with hyperparameter \code{lambda_min}.}
\item{\code{edf_1se}}{Number of effective degrees of freedom in the  trend
filtering estimator with hyperparameter \code{lambda_1se}.}
\item{\code{i_min}}{Index of \code{lambda} that gives \code{lambda_min}.}
\item{\code{i_1se}}{Index of \code{lambda} that gives \code{lambda_1se}.}
\item{\code{fitted_values}}{The fitted values of all trend filtering estimates,
return as a matrix with \code{length(lambda)} columns, with \code{fitted_values[,i]}
corresponding to the trend filtering estimate with hyperparameter
\code{lambda[i]}.
}
\item{\code{admm_params}}{A list of the parameter values used by the ADMM
algorithm used to solve the trend filtering convex optimization.}
\item{\code{obj_func}}{The relative change in the objective function over the
ADMM algorithm's final iteration, for every candidate hyperparameter in
\code{lambda}.}
\item{\code{n_iter}}{Total number of iterations taken by the ADMM algorithm, for
every candidate hyperparameter in \code{lambda}. If an element of \code{n_iter}
is exactly equal to \code{admm_params$max_iter}, then the
ADMM algorithm stopped before reaching the objective tolerance
\code{admm_params$obj_tol}. In these situations, you may need to
increase the maximum number of tolerable iterations by passing a
\code{max_iter} argument to \code{sure_trendfilter()} in order to ensure that the ADMM
solution has converged to satisfactory precision.}
\item{\code{x}}{Vector of observed values for the input variable.}
\item{\code{y}}{Vector of observed values for the output variable (if originally
present, observations with \code{is.na(y)} or \code{weights == 0} are dropped).}
\item{\code{weights}}{Vector of weights for the observed outputs.}
\item{\code{k}}{Degree of the trend filtering estimates.}
\item{\code{status}}{For internal use. Output from the C solver.}
\item{\code{call}}{The function call.}
\item{\code{scale}}{For internal use.}
}
}
\description{
For every candidate hyperparameter value, compute an unbiased estimate of the
trend filtering model's predictive mean-squared error. See the \strong{Details}
section for guidelines on when \code{\link[=sure_trendfilter]{sure_trendfilter()}} should be used versus
\code{\link[=cv_trendfilter]{cv_trendfilter()}}.
}
\details{
Our recommendations for when to use \code{\link[=sure_trendfilter]{sure_trendfilter()}} versus
\code{\link[=cv_trendfilter]{cv_trendfilter()}} are summarized in the table below. See Section 3.5 of
\href{https://arxiv.org/abs/1908.07151}{Politsch et al. (2020a)} for more details.\tabular{lc}{
   Scenario \tab Hyperparameter optimization \cr
   \code{x} is unevenly sampled \tab \code{\link[=cv_trendfilter]{cv_trendfilter()}} \cr
   \code{x} is evenly sampled and measurement variances for \code{y} are not available \tab \code{\link[=cv_trendfilter]{cv_trendfilter()}} \cr
   \code{x} is evenly sampled and measurement variances for \code{y} are available \tab \code{\link[=sure_trendfilter]{sure_trendfilter()}} \cr
}


For our purposes, an evenly sampled data set with some discarded pixels
(either sporadically or in wide consecutive chunks) is still considered to
be evenly sampled. When \code{x} is evenly sampled on a transformed scale, we
recommend transforming to that scale and carrying out the full trend
filtering analysis on that scale. See the \code{\link[=sure_trendfilter]{sure_trendfilter()}} examples for
a case when the inputs are evenly sampled on the \code{log10(x)} scale.
}
\examples{
data("quasar_spectrum")
head(quasar_spectrum)

x <- quasar_spectrum$log10_wavelength
y <- quasar_spectrum$flux
weights <- quasar_spectrum$weights

sure_tf <- sure_trendfilter(x, y, weights)
}
\references{
\enumerate{
\item Politsch et al. (2020a). Trend filtering – I. A modern statistical tool
for time-domain astronomy and astronomical spectroscopy. \emph{MNRAS}, 492(3),
p. 4005-4018.
[\href{https://academic.oup.com/mnras/article/492/3/4005/5704413}{Publisher}]
[\href{https://arxiv.org/abs/1908.07151}{arXiv}].
\item Politsch et al. (2020b). Trend Filtering – II. Denoising astronomical
signals with varying degrees of smoothness. \emph{MNRAS}, 492(3), p. 4019-4032.
[\href{https://academic.oup.com/mnras/article/492/3/4019/5704414}{Publisher}]
[\href{https://arxiv.org/abs/2001.03552}{arXiv}].
}
}
