% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hyperparameter-tuning.R
\name{sure_trendfilter}
\alias{sure_trendfilter}
\title{Optimize the trend filtering hyperparameter by minimizing Stein's unbiased
risk estimate}
\usage{
sure_trendfilter(x, y, weights, nlambdas = 250L, ...)
}
\arguments{
\item{x}{Vector of observed values for the input variable.}

\item{y}{Vector of observed values for the output variable.}

\item{weights}{(Optional) Weights for the observed outputs, defined as the reciprocal
variance of the additive noise that contaminates the output signal. When
the noise is expected to have an equal variance \mjseqn{\sigma^2} for all
observations, a scalar may be passed to \code{weights}, i.e.
\verb{weights = }\mjseqn{1/\sigma^2}. Otherwise, \code{weights} must be a vector with
the same length as \code{x} and \code{y}.}

\item{nlambdas}{Number of hyperparameter values to test during cross validation. Defaults
to \code{nlambdas = 250}. The hyperparameter grid is internally constructed to
span the full trend filtering model space (which is bookended by a global
polynomial solution and an interpolating solution), with \code{nlambdas}
controlling the granularity of the hyperparameter grid.}

\item{...}{Additional named arguments to pass to \code{\link[=trendfilter]{trendfilter()}}.}
}
\value{
An object of class \code{'sure_trendfilter'} and subclass \code{'trendfilter'}.
This is a list with the following elements:
\describe{
\item{\code{lambdas}}{Vector of candidate hyperparameter values (always returned
in descending order).}
\item{\code{edfs}}{Number of effective degrees of freedom in the trend filtering
estimator, for every hyperparameter value in \code{lambdas}.}
\item{\code{errors}}{Vector of mean-squared prediction errors estimated by SURE,
for every hyperparameter value in \code{lambdas}.}
\item{\code{se_errors}}{Vector of estimated standard errors for the \code{errors}.}
\item{\code{lambda_min}}{Hyperparameter value in \code{lambdas} that minimizes the SURE
validation error curve.}
\item{\code{lambda_1se}}{The largest hyperparameter value in \code{lambdas} that has a
SURE error within one standard error of \code{min(errors)}. We call this the
"1-standard-error rule" hyperparameter, and it serves as an Occam's
razor-esque heuristic. More precisely, given two models with approximately
equal performance (here, in terms of predictive MSE), it may be wise to opt
for the simpler model, i.e. the model with the larger hyperparameter value /
fewer effective degrees of freedom.}
\item{\code{edf_min}}{Number of effective degrees of freedom in the trend
filtering estimator with hyperparameter \code{lambda_min}.}
\item{\code{edf_1se}}{Number of effective degrees of freedom in the  trend
filtering estimator with hyperparameter \code{lambda_1se}.}
\item{\code{i_min}}{Index of \code{lambdas} that gives \code{lambda_min}.}
\item{\code{i_1se}}{Index of \code{lambdas} that gives \code{lambda_1se}.}
\item{\code{obj_func}}{The relative change in the objective function over the
ADMM algorithm's final iteration, for every candidate hyperparameter in
\code{lambdas}.}
\item{\code{n_iter}}{Total number of iterations taken by the ADMM algorithm, for
every candidate hyperparameter in \code{lambdas}. If an element of \code{n_iter}
is exactly equal to \code{model$admm_params$max_iter} (see below), then the ADMM
algorithm stopped before reaching the objective tolerance
\code{model$admm_params$obj_tol}. In these situations, you may need to increase
the maximum number of tolerable iterations via the
\code{optimization_params$max_iter} argument of \code{sure_trendfilter()} in order to
ensure that the ADMM solution has converged to satisfactory precision.}
\item{\code{training_errors}}{The "in-sample" MSE between the observed outputs \code{y}
and the trend filtering estimate, for every hyperparameter value in
\code{lambdas}.}
\item{\code{optimisms}}{SURE-estimated optimisms, i.e.
\code{optimisms = errors - training_errors}.}
\item{\code{x}}{Vector of observed values for the input variable.}
\item{\code{y}}{Vector of observed values for the output variable (if originally
present, observations with \code{is.na(y)} or \code{weights == 0} are dropped).}
\item{\code{weights}}{Vector of weights for the observed outputs.}
\item{\code{model}}{A list containing the trend filtering model fit object, the
ADMM parameter settings, and other modeling objects that are useful to pass
along to functions that operate on the \code{sure_trendfilter()} output.}
}
}
\description{
For every candidate hyperparameter value, compute an unbiased estimate of the
trend filtering model's predictive mean-squared error. See the details
section for guidelines on when \code{\link[=sure_trendfilter]{sure_trendfilter()}} should be used versus
\code{\link[=cv_trendfilter]{cv_trendfilter()}}. Generic functions like \code{predict()} and \code{residuals()}
work on \code{sure_trendfilter} output.
}
\details{
Our recommendations for when to use \code{\link[=sure_trendfilter]{sure_trendfilter()}} versus
\code{\link[=cv_trendfilter]{cv_trendfilter()}} are summarized in the table below. See Section 3.5 of
\href{https://arxiv.org/abs/1908.07151}{Politsch et al. (2020a)} for more details.\tabular{lc}{
   Scenario \tab Hyperparameter optimization \cr
   \code{x} is unevenly sampled \tab \code{\link[=cv_trendfilter]{cv_trendfilter()}} \cr
   \code{x} is evenly sampled and measurement variances for \code{y} are not available \tab \code{\link[=cv_trendfilter]{cv_trendfilter()}} \cr
   \code{x} is evenly sampled and measurement variances for \code{y} are available \tab \code{\link[=sure_trendfilter]{sure_trendfilter()}} \cr
}


For our purposes, an evenly sampled data set with some discarded pixels
(either sporadically or in wide consecutive chunks) is still considered to
be evenly sampled. When \code{x} is evenly sampled on a transformed scale, we
recommend transforming to that scale and carrying out the full trend
filtering analysis on that scale. See the \code{\link[=sure_trendfilter]{sure_trendfilter()}} examples for
a case when the inputs are evenly sampled on the \code{log10(x)} scale.
}
\examples{
data(quasar_spectrum)
head(spec)

sure_tf <- sure_trendfilter(spec$log10_wavelength, spec$flux, spec$weights)
}
\references{
\enumerate{
\item Politsch et al. (2020a). Trend filtering – I. A modern statistical tool
for time-domain astronomy and astronomical spectroscopy. \emph{MNRAS}, 492(3),
p. 4005-4018.
[\href{https://academic.oup.com/mnras/article/492/3/4005/5704413}{Publisher}]
[\href{https://arxiv.org/abs/1908.07151}{arXiv}]
[\href{https://capolitsch.github.io/trendfiltering/authors.html}{BibTeX}].
\item Politsch et al. (2020b). Trend Filtering – II. Denoising astronomical
signals with varying degrees of smoothness. \emph{MNRAS}, 492(3), p. 4019-4032.
[\href{https://academic.oup.com/mnras/article/492/3/4019/5704414}{Publisher}]
[\href{https://arxiv.org/abs/2001.03552}{arXiv}]
[\href{https://capolitsch.github.io/trendfiltering/authors.html}{BibTeX}].
}
}
