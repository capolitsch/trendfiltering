% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.R
\name{predict.cv_tf}
\alias{predict.cv_tf}
\alias{predict.sure_tf}
\title{Predict values from a trend filtering object}
\usage{
\method{predict}{cv_tf}(
  obj,
  validation_error_metric = "WMAE",
  lambda_choice = c("lambda_min", "lambda_1se"),
  x_eval,
  nx_eval = 1500L
)

\method{predict}{sure_tf}(
  obj,
  lambda_choice = c("lambda_min", "lambda_1se"),
  x_eval,
  nx_eval = 250L
)
}
\arguments{
\item{obj}{An object of class \code{\link[=cv_trendfilter]{"cv_tf"}} or
\code{\link[=sure_trendfilter]{"sure_tf"}}.}

\item{validation_error_metric}{(For class \code{"cv_tf"} only) A string or
index specifying which cross validation error curve stored within the
\code{cv_tf} object will be used to choose the trend filtering hyperparameter.
The first 4 options are \code{"WMAE"}, \code{"WMSE"}, \code{"MAE"}, and \code{"MSE"}.
Therefore, for example, one could select the CV curve based on mean absolute
deviations error by passing either
\code{validation_error_metric = "MAE"} or \code{validation_error_metric = 3}. If the
user passed custom error functions to \code{\link[=cv_trendfilter]{cv_trendfilter()}}, then these will
arise as additional options that follow the first 4, and their string
designations can be seen by running \code{names(obj$validation_error_funcs)}.}

\item{lambda_choice}{One of \code{c("lambda_min","lambda_1se")}. The choice
of hyperparameter that is used for optimized trend filtering estimate.
Defaults to \code{lambda_choice = "lambda_min"}.
\itemize{
\item{\code{"lambda_min"}}: The hyperparameter value that minimizes the cross
validation error curve.
\item{\code{"lambda_1se"}}: The largest hyperparameter value with a cross
validation error within 1 standard error of the minimum cross validation
error. This choice therefore favors simpler (i.e. smoother) trend filtering
estimates.
}}

\item{x_eval}{(Optional) A grid of inputs to evaluate the optimized trend
filtering estimate on.}

\item{nx_eval}{Integer. The length of the input grid that the optimized
trend filtering estimate is evaluated on; i.e. if nothing is passed to
\code{x_eval}, then it is defined as
\code{x_eval = seq(min(x), max(x), length = nx_eval)}.}
}
\value{
The optimized trend filtering estimate, evaluated at \code{x_eval}.
}
\description{
Evaluate an optimized trend filtering object on a grid of input values.
The predict function can be called on an object of class
\code{\link[=cv_trendfilter]{"cv_tf"}} or \code{\link[=sure_trendfilter]{"sure_tf"}}, and the
arguments \code{validation_error_metric} (for \code{"cv_tf"} objects only) and
\code{lambda_choice} should be used to specify the desired method for optimizing
the trend filtering hyperparameter.
}
\details{
The motivation for using \code{lambda_choice = "lambda_1se"} is essentially
Occam's razor: the two models yield results that are quantitatively very
close, so we favor the simpler model. See Section 7.10 of
\href{https://web.stanford.edu/~hastie/Papers/ESLII.pdf}{Hastie, Tibshirani, and Friedman (2009)}
for more details on the "one-standard-error rule".
}
\examples{
data(eclipsing_binary)
head(EB)

cv_tf <- cv_trendfilter(
  x = EB$phase,
  y = EB$flux,
  weights = 1 / EB$std_err^2,
  optimization_params = list(
    max_iter = 1e4,
    obj_tol = 1e-6,
    thinning = TRUE
  )
)

tf_preds <- predict(cv_tf,
  validation_error_metric = "MAE",
  lambda_choice = "lambda_1se"
)
}
\seealso{
\code{\link[=cv_trendfilter]{cv_trendfilter()}}, \code{\link[=sure_trendfilter]{sure_trendfilter()}}
}
